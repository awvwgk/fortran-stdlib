#:include "common.fypp"
#:set IR_KINDS_TYPES = INT_KINDS_TYPES + REAL_KINDS_TYPES

module test_stats_corr
    use stdlib_test, only : new_unittest, unittest_type, error_type, check
    use stdlib_stats, only: corr
    use stdlib_kinds, only : int8, int16, int32, int64, sp, dp, qp
    use,intrinsic :: ieee_arithmetic, only : ieee_is_nan
    implicit none
    private
  
    public :: collect_stats_corr

    #:for k1, t1 in REAL_KINDS_TYPES
    ${t1}$, parameter :: ${k1}$tol = 1000 * epsilon(1._${k1}$)
    #:endfor

    #:for k1, t1 in IR_KINDS_TYPES
    ${t1}$, parameter :: d1_${k1}$(5) = [${t1}$ :: 1, 2, 3, 4, 5]
    ${t1}$, parameter :: d2_${k1}$(4, 3) =&
                                   reshape([${t1}$ :: 1, 3, 5, 22,&
                                   3, 4, 6, 20,&
                                   15, 14, 13, 12], [4, 3])
    #:endfor

    #:for k1, t1 in CMPLX_KINDS_TYPES
    complex(${k1}$), parameter :: c1_${k1}$(5) =&
                            [ cmplx(0.57706_${k1}$, 0.00000_${k1}$, kind = ${k1}$),&
                            cmplx(0.00000_${k1}$, 1.44065_${k1}$, kind = ${k1}$),&
                            cmplx(1.26401_${k1}$, 0.00000_${k1}$, kind = ${k1}$),&
                            cmplx(0.00000_${k1}$, 0.88833_${k1}$, kind = ${k1}$),&
                            cmplx(1.14352_${k1}$, 0.00000_${k1}$, kind = ${k1}$)]
    complex(${k1}$), parameter :: c2_${k1}$(2,3) &
                            = reshape([ cmplx(1._${k1}$, 0._${k1}$, kind = ${k1}$),&
                            cmplx(0._${k1}$, 2._${k1}$, kind = ${k1}$),&
                            cmplx(3._${k1}$, 0._${k1}$, kind = ${k1}$),&
                            cmplx(0._${k1}$, 4._${k1}$, kind = ${k1}$),&
                            cmplx(5._${k1}$, 0._${k1}$, kind = ${k1}$),&
                            cmplx(0._${k1}$, 6._${k1}$, kind = ${k1}$)], [2, 3])
    #:endfor

contains

    !> Collect all exported unit tests
    subroutine collect_stats_corr(testsuite)
        !> Collection of tests
        type(unittest_type), allocatable, intent(out) :: testsuite(:)

        testsuite = [ &
            new_unittest("test_${k1}$_1dim", test_${k1}$_1dim) &
            #:for k1,t1 in IR_KINDS_TYPES
            , new_unittest("test_${k1}$_1dim", test_${k1}$_1dim) &
            , new_unittest("test_${k1}$_1dim_mask_nan", test_${k1}$_1dim_mask_nan) &
            , new_unittest("test_${k1}$_1dim_mask", test_${k1}$_1dim_mask) &
            , new_unittest("test_${k1}$_2dim_dim_mask_nan", test_${k1}$_2dim_dim_mask_nan) &
            , new_unittest("test_${k1}$_2dim_dim", test_${k1}$_2dim_dim) &
            , new_unittest("test_${k1}$_2dim_dim_mask", test_${k1}$_2dim_dim_mask) &
            #:endfor
            #:for k1,t1 in CMPLX_KINDS_TYPES
            , new_unittest("test_c_${k1}$_1dim_dim",test_c_${k1}$_1dim_dim) &
            , new_unittest("test_c_${k1}$_1dim_dim_mask",test_c_${k1}$_1dim_dim_mask) &
            , new_unittest("test_c_${k1}$_1dim_dim_mask_nan",test_c_${k1}$_1dim_dim_mask_nan) &
            , new_unittest("test_c_${k1}$_2dim_dim",test_c_${k1}$_2dim_dim) &
            , new_unittest("test_c_${k1}$_2dim_dim_mask",test_c_${k1}$_2dim_dim_mask) &
            #:endfor
            ]

    end subroutine collect_stats_corr

    #:for k1, t1 in IR_KINDS_TYPES
    #:if k1[0] == 'i'
        #:set ko = 'dp'
        #:set to = 'real(dp)'
    #:else
        #:set ko = k1
        #:set to = t1
    #:endif
    subroutine test_${k1}$_1dim(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, abs(corr(d1_${k1}$, 1) - 1._${ko}$) < ${ko}$tol&
            , '${k1}$ check 1')
    end subroutine

    subroutine test_${k1}$_1dim_mask_nan(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, ieee_is_nan(corr(d1_${k1}$, 1, .false.)), '${k1}$ check 2')
        call check(error, ieee_is_nan(corr(d1_${k1}$, 1, d1_${k1}$ == 1)), '${k1}$ check 3')
        call check(error, ieee_is_nan(corr(d1_${k1}$, 1, d1_${k1}$ < -999)), '${k1}$ check 5')

    end subroutine

    subroutine test_${k1}$_1dim_mask(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, abs(corr(d1_${k1}$, 1, d1_${k1}$ < 5) - 1._${ko}$) < ${ko}$tol, '${k1}$ check 4')

    end subroutine

    subroutine test_${k1}$_2dim_dim_mask_nan(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, any(ieee_is_nan(corr(d2_${k1}$, 1, mask = .false.)))&
            , '${k1}$ check 6')
        call check(error, any(ieee_is_nan(corr(d2_${k1}$, 2, mask = .false.)))&
            , '${k1}$ check 7')
        call check(error, any(ieee_is_nan(corr(d2_${k1}$, 1, mask = d2_${k1}$ < 10)))&
            , '${k1}$ check 10')

    end subroutine

    subroutine test_${k1}$_2dim_dim(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, all( abs( corr(d2_${k1}$, 1) - reshape([&
            1._${ko}$, 0.999443910360031609085612903764355119_${ko}$,&
            -0.870544389237152567793676128589371501_${ko}$,&
            0.999443910360031609085612903764355119_${ko}$,&
            1._${ko}$, -0.862615766297429009756350554166911403_${ko}$,&
            -0.870544389237152567793676128589371501_${ko}$,&
            -0.862615766297429009756350554166911306_${ko}$, 1._${ko}$]&
            ,[ size(d2_${k1}$, 2), size(d2_${k1}$, 2)])&
            ) < ${ko}$tol)&
            , '${k1}$ check 8')
        if(allocated(error)) return

        call check(error, all( abs( corr(d2_${k1}$, 2) - reshape([&
             1._${ko}$, 0.998742137866914189429286727903477642_${ko}$,&
             0.999846989517886389758615572495770350_${ko}$,&
             -0.998337488459582677318066490725496965_${ko}$,&
             0.998742137866914189429286727903477642_${ko}$,&
             1._${ko}$, 0.999466429486246313938223164597895989_${ko}$,&
             -0.994191625601920073318918379418422629_${ko}$,&
             0.999846989517886389758615572495770254_${ko}$,&
             0.999466429486246313938223164597895893_${ko}$, 1._${ko}$,&
             -0.997176464952737990432880505612071673_${ko}$,&
             -0.998337488459582677318066490725497062_${ko}$,&
             -0.994191625601920073318918379418422629_${ko}$,&
             -0.997176464952737990432880505612071769_${ko}$, 1._${ko}$]&      
            ,[ size(d2_${k1}$, 1), size(d2_${k1}$, 1)])&
            ) < ${ko}$tol)&
            , '${k1}$ check 9')

    end subroutine

    subroutine test_${k1}$_2dim_dim_mask(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, all( abs( corr(d2_${k1}$, 1, mask = d2_${k1}$ < 22) - reshape([&
              1._${ko}$, 0.981980506061965715697438684370287590_${ko}$, -1._${ko}$,&
              0.981980506061965715697438684370287590_${ko}$, 1._${ko}$,&
              -0.862615766297429009756350554166911403_${ko}$, -1._${ko}$,&
              -0.862615766297429009756350554166911403_${ko}$, 1._${ko}$]&      
            ,[ size(d2_${k1}$, 2), size(d2_${k1}$, 2)])&
            ) < ${ko}$tol)&
            , '${k1}$ check 11')
        call check(error, all( abs( corr(d2_${k1}$, 2, mask = d2_${k1}$ < 22) - reshape([&
            1._${ko}$, 0.998742137866914189429286727903477642_${ko}$, 0.999846989517886389758615572495770158_${ko}$,&
            -1._${ko}$, 0.998742137866914189429286727903477642_${ko}$, 1._${ko}$,&
            0.999466429486246313938223164597896085_${ko}$, -1._${ko}$, 0.999846989517886389758615572495770158_${ko}$,&
            0.999466429486246313938223164597896085_${ko}$, 1._${ko}$, -1._${ko}$, -1._${ko}$, -1._${ko}$,&
            -1._${ko}$, 1._${ko}$]&       
            ,[ size(d2_${k1}$, 1), size(d2_${k1}$, 1)])&
            ) < ${ko}$tol)&
            , '${k1}$ check 12')
        call check(error, all(abs(corr(d2_${k1}$, 1, mask = d2_${k1}$ < 1000) - corr(d2_${k1}$, 1))&
            < ${ko}$tol)&
            , '${k1}$ check 13')
        call check(error, all(abs(corr(d2_${k1}$, 2, mask = d2_${k1}$ < 1000) - corr(d2_${k1}$, 2))&
            < ${ko}$tol)&
            , '${k1}$ check 14')

    end subroutine
    #:endfor

    #:for k1,t1 in CMPLX_KINDS_TYPES
    subroutine test_c_${k1}$_1dim_dim(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, abs(corr(c1_${k1}$, dim=1) - 1._${k1}$)  < ${k1}$tol&
            , 'c${k1}$ check 1')
    end subroutine

    subroutine test_c_${k1}$_1dim_dim_mask(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, abs(corr(c1_${k1}$, 1, aimag(c1_${k1}$) == 0) - 1._${k1}$ ) < ${k1}$tol&
            , 'c${k1}$ check 2')
    end subroutine

    subroutine test_c_${k1}$_1dim_dim_mask_nan(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error


        call check(error, ieee_is_nan(corr(c1_${k1}$, 1, aimag(c1_${k1}$) == -99 )) &
            , 'c${k1}$ check 3')
        call check(error, ieee_is_nan(real(corr(c1_${k1}$, 1, .false.)))&
            , 'c${k1}$ check 4')
    end subroutine

    subroutine test_c_${k1}$_2dim_dim(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error

        call check(error, all( abs( corr(c2_${k1}$, 1) - reshape([&
               (1._${k1}$,0._${k1}$), &
               (0.983869910099907466420036414241761561_${k1}$,-0.178885438199983175712733893498502091_${k1}$), &
               (0.973417168333575970450681120412876690_${k1}$,-0.229039333725547287164866145979500408_${k1}$), &
               (0.983869910099907466420036414241761561_${k1}$,0.178885438199983175712733893498502091_${k1}$), &
               (1._${k1}$,0._${k1}$), &
               (0.998687663476588594659210448179032683_${k1}$,-5.121475197315838946970309990661705927E-0002_${k1}$), &
               (0.973417168333575970450681120412876594_${k1}$,0.229039333725547287164866145979500408_${k1}$), &
               (0.998687663476588594659210448179032683_${k1}$,5.121475197315838946970309990661705927E-0002_${k1}$), &
               (1._${k1}$,0._${k1}$)]&
            ,[ size(c2_${k1}$, 2), size(c2_${k1}$, 2)])&
            ) < ${k1}$tol)&
            , 'c${k1}$ check 6')
        call check(error, all( abs( corr(c2_${k1}$, 2) - reshape([&
            (1._${k1}$,0._${k1}$), (0._${k1}$,1._${k1}$),&
            (0._${k1}$,-1._${k1}$), (1._${k1}$,0._${k1}$)]&
            ,[ size(c2_${k1}$, 1), size(c2_${k1}$, 1)])&
            ) < ${k1}$tol)&
            , 'c${k1}$ check 7')
    end subroutine

    subroutine test_c_${k1}$_2dim_dim_mask(error)
        !> Error handling
        type(error_type), allocatable, intent(out) :: error
        call check(error, all( abs( corr(c2_${k1}$, 2, mask = aimag(c2_${k1}$) < 6) - reshape([&
             (1._${k1}$,0._${k1}$), (0._${k1}$,1._${k1}$)&
             ,(0._${k1}$,-1._${k1}$), (1._${k1}$,0._${k1}$)]&
            ,[ size(c2_${k1}$, 1), size(c2_${k1}$, 1)])&
            ) < ${k1}$tol)&
            , 'c${k1}$ check 8')
        call check(error, all( abs( corr(c2_${k1}$, 1, mask = aimag(c2_${k1}$) < 1000) - corr(c2_${k1}$, 1))&
            < ${k1}$tol)&
            , 'c${k1}$ check 9')
        call check(error, all( abs( corr(c2_${k1}$, 2, mask = aimag(c2_${k1}$) < 1000) - corr(c2_${k1}$, 2))&
            < ${k1}$tol)&
            , 'c${k1}$ check 10')
    end subroutine
    #:endfor

end module test_stats_corr

program tester
    use, intrinsic :: iso_fortran_env, only : error_unit
    use stdlib_test, only : run_testsuite, new_testsuite, testsuite_type
    use test_stats_corr, only : collect_stats_corr
    implicit none
    integer :: stat, is
    type(testsuite_type), allocatable :: testsuites(:)
    character(len=*), parameter :: fmt = '("#", *(1x, a))'

    stat = 0

    testsuites = [ &
        new_testsuite("stats_corr", collect_stats_corr) &
        ]

    do is = 1, size(testsuites)
        write(error_unit, fmt) "Testing:", testsuites(is)%name
        call run_testsuite(testsuites(is)%collect, error_unit, stat)
    end do

    if (stat > 0) then
        write(error_unit, '(i0, 1x, a)') stat, "test(s) failed!"
        error stop
    end if
end program
