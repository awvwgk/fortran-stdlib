! SPDX-Identifier: MIT

#:set BLAS_KIND = ["sp", "dp"]
#:set BLAS_REAL = [("s", "sp"), ("d", "dp")]
#:set BLAS_COMPLEX = [("c", "sp"), ("z", "dp")]
#:set BLAS_COMPLEX_REAL = [("cs", "sp"), ("zd", "dp")]
#:set BLAS_REAL_COMPLEX = [("sc", "sp"), ("dz", "dp")]

!> Interfaces to level 1 BLAS routines.
module stdlib_linalg_blas1
  use stdlib_kinds, only : ik => int32, sp, dp
  implicit none
  private

  public :: blas_axpy, blas_copy, blas_dot, blas_dotc, blas_dotu, blas_dsdot, blas_sdsdot, &
    & blas_rotg, blas_rotm, blas_rotmg, blas_scal, blas_rot, blas_swap, blas_abs1, &
    & blas_asum, blas_nrm2, blas_iamax

  !> Constant times a vector plus a vector.
  interface blas_axpy
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$axpy(n, a, x, incx, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: a
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$axpy
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$axpy(n, a, x, incx, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: a
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$axpy
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_axpy_r${wp}$
    module procedure :: blas_axpy_c${wp}$
  #:endfor
  end interface blas_axpy

  !> Copies a vector, x, to a vector, y.
  interface blas_copy
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$copy(n, x, incx, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$copy
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$copy(n, x, incx, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$copy
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_copy_r${wp}$
    module procedure :: blas_copy_c${wp}$
  #:endfor
  end interface blas_copy

  !> Forms the dot product of two vectors.
  interface blas_dot
  #:for prefix, wp in BLAS_REAL
    pure function ${prefix}$dot(n, x, incx, y, incy) result(dot)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp) :: dot
    end function ${prefix}$dot
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_dot_r${wp}$
  #:endfor
  end interface blas_dot

  !> Compute the inner product of two vectors with extended
  !> precision accumulation and result.
  !>
  !> Returns D.P. dot product accumulated in D.P., for S.P. SX and SY
  !> DSDOT = sum for I = 0 to N-1 of  SX(LX+I*INCX) * SY(LY+I*INCY),
  !> where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
  !> defined in a similar way using INCY.
  interface blas_dsdot
    pure function dsdot(n, sx, incx, sy, incy)
      import :: ik, dp, sp
      integer(ik), intent(in) :: n
      real(sp), intent(in) :: sx(*)
      integer(ik), intent(in) :: incx
      real(sp), intent(in) :: sy(*)
      integer(ik), intent(in) :: incy
      real(dp) :: dsdot
    end function dsdot

    module procedure :: blas_dsdot_rspdp
  end interface blas_dsdot

  !> Compute the inner product of two vectors with extended
  !> precision accumulation.
  !>
  !> Returns S.P. result with dot product accumulated in D.P.
  !> SDSDOT = SB + sum for I = 0 to N-1 of SX(LX+I*INCX)*SY(LY+I*INCY),
  !> where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is
  !> defined in a similar way using INCY.
  interface blas_sdsdot
    pure function sdsdot(n, sb, sx, incx, sy, incy)
      import :: ik, sp
      integer(ik), intent(in) :: n
      real(sp), intent(in) :: sb
      real(sp), intent(in) :: sx(*)
      integer(ik), intent(in) :: incx
      real(sp), intent(in) :: sy(*)
      integer(ik), intent(in) :: incy
      real(sp) :: sdsdot
    end function sdsdot

    module procedure :: blas_sdsdot_rsp
  end interface blas_sdsdot

  !> Forms the dot product of two complex vectors
  !>
  !>    DOTC = X^H * Y
  interface blas_dotc
  #:for prefix, wp in BLAS_COMPLEX
    pure function ${prefix}$dotc(n, x, incx, y, incy) result(dotc)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      complex(wp) :: dotc
    end function ${prefix}$dotc
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_dotc_c${wp}$
  #:endfor
  end interface blas_dotc

  !> Forms the dot product of two complex vectors
  !>
  !>    DOTU = X^T * Y
  interface blas_dotu
  #:for prefix, wp in BLAS_COMPLEX
    pure function ${prefix}$dotu(n, x, incx, y, incy) result(dotu)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      complex(wp) :: dotu
    end function ${prefix}$dotu
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_dotu_c${wp}$
  #:endfor
  end interface blas_dotu

  !> The computation uses the formulas
  !>    sigma = sgn(a)    if |a| >  |b|
  !>          = sgn(b)    if |b| >= |a|
  !>    r = sigma*sqrt( a**2 + b**2 )
  !>    c = 1; s = 0      if r = 0
  !>    c = a/r; s = b/r  if r != 0
  !> The subroutine also computes
  !>    z = s    if |a| > |b|,
  !>      = 1/c  if |b| >= |a| and c != 0
  !>      = 1    if c = 0
  !> This allows c and s to be reconstructed from z as follows:
  !>    If z = 1, set c = 0, s = 1.
  !>    If |z| < 1, set c = sqrt(1 - z**2) and s = z.
  !>    If |z| > 1, set c = 1/z and s = sqrt( 1 - c**2).
  interface blas_rotg
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$rotg(a, b, c, s)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      real(wp), intent(in) :: a
      real(wp), intent(in) :: b
      real(wp), intent(out) :: c
      real(wp), intent(out) :: s
    end subroutine ${prefix}$rotg
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$rotg(a, b, c, s)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      complex(wp), intent(in) :: a
      complex(wp), intent(in) :: b
      real(wp), intent(out) :: c
      complex(wp), intent(out) :: s
    end subroutine ${prefix}$rotg
  #:endfor
  end interface blas_rotg

  !> Apply the modified givens transformation, h, to the 2 by n matrix
  !>
  !> (dx**t) , where **t indicates transpose. the elements of dx are in (dy**t)
  !>
  !> dx(lx+i*incx), i = 0 to n-1, where lx = 1 if incx .ge. 0, else
  !> lx = (-incx)*n, and similarly for sy using ly and incy.
  !> with dparam(1)=dflag, h has one of the following forms.
  !>
  !> dflag=-1.d0     dflag=0.d0        dflag=1.d0     dflag=-2.d0
  !>
  !>   (dh11  dh12)    (1.d0  dh12)    (dh11  1.d0)    (1.d0  0.d0)
  !> h=(          )    (          )    (          )    (          )
  !>   (dh21  dh22),   (dh21  1.d0),   (-1.d0 dh22),   (0.d0  1.d0).
  interface blas_rotm
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$rotm(n, x, incx, y, incy, param)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp), intent(in) :: param(5)
    end subroutine ${prefix}$rotm
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_rotm_r${wp}$
  #:endfor
  end interface blas_rotm

  !> construct the modified givens transformation matrix h which zeros
  !> the second component of the 2-vector  (dsqrt(dd1)*dx1,dsqrt(dd2)
  !> dy2)**t. With dparam(1)=dflag, h has one of the following forms..
  !>
  !> dflag=-1.d0     dflag=0.d0        dflag=1.d0     dflag=-2.d0
  !>
  !>   (dh11  dh12)    (1.d0  dh12)    (dh11  1.d0)    (1.d0  0.d0)
  !> h=(          )    (          )    (          )    (          )
  !>   (dh21  dh22),   (dh21  1.d0),   (-1.d0 dh22),   (0.d0  1.d0).
  !> Locations 2-4 of dparam contain dh11, dh21, dh12, and dh22
  !> respectively. (values of 1.d0, -1.d0, or 0.d0 implied by the
  !> value of dparam(1) are not stored in dparam.)
  !>
  !> The values of gamsq and rgamsq set in the data statement may be
  !> inexact.  this is ok as they are only used for testing the size
  !> of dd1 and dd2.  all actual scaling of data is done using gam.
  interface blas_rotmg
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$rotmg(d1, d2, x1, y1, param)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      real(wp), intent(inout) :: d1
      real(wp), intent(inout) :: d2
      real(wp), intent(inout) :: x1
      real(wp), intent(in) :: y1
      real(wp), intent(out) :: param(5)
    end subroutine ${prefix}$rotmg
  #:endfor
  end interface blas_rotmg

  !> Scales a vector by a constant.
  interface blas_scal
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$scal(n, a, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: a
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$scal
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$scal(n, a, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: a
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$scal
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX_REAL
    pure subroutine ${prefix}$scal(n, a, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: a
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$scal
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_scal_r${wp}$
    module procedure :: blas_scal_c${wp}$
    module procedure :: blas_scal_rc${wp}$
  #:endfor
  end interface blas_scal

  !> Applies a plane rotation.
  interface blas_rot
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$rot(n, x, incx, y, incy, c, s)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp), intent(in) :: c
      real(wp), intent(in) :: s
    end subroutine ${prefix}$rot
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX_REAL
    pure subroutine ${prefix}$rot(n, x, incx, y, incy, c, s)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp), intent(in) :: c
      real(wp), intent(in) :: s
    end subroutine ${prefix}$rot
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_rot_r${wp}$
    module procedure :: blas_rot_c${wp}$
  #:endfor
  end interface blas_rot

  !> Interchanges two vectors.
  interface blas_swap
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$swap(n, x, incx, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$swap
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$swap(n, x, incx, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$swap
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_swap_r${wp}$
    module procedure :: blas_swap_c${wp}$
  #:endfor
  end interface blas_swap

  !> Computes |Re(.)| + |Im(.)| of a complex number
  interface blas_abs1
  #:for prefix, wp in BLAS_REAL_COMPLEX
    pure function ${prefix}$abs1(z) result(abs1)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      complex(wp), intent(in) :: z
      real(wp) :: abs1
    end function ${prefix}$abs1
  #:endfor
  end interface blas_abs1

  !> Takes the sum of the absolute values.
  interface blas_asum
  #:for prefix, wp in BLAS_REAL
    pure function ${prefix}$asum(n, x, incx) result(asum)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp) :: asum
    end function ${prefix}$asum
  #:endfor

  #:for prefix, wp in BLAS_REAL_COMPLEX
    pure function ${prefix}$asum(n, x, incx) result(asum)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp) :: asum
    end function ${prefix}$asum
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_asum_r${wp}$
    module procedure :: blas_asum_c${wp}$
  #:endfor
  end interface blas_asum

  !> Returns the euclidean norm of a vector via the function
  !> name, so that
  !>
  !>    NRM2 := sqrt( x'*x )
  interface blas_nrm2
  #:for prefix, wp in BLAS_REAL
    pure function ${prefix}$nrm2(n, x, incx) result(nrm2)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp) :: nrm2
    end function ${prefix}$nrm2
  #:endfor

  #:for prefix, wp in BLAS_REAL_COMPLEX
    pure function ${prefix}$nrm2(n, x, incx) result(nrm2)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp) :: nrm2
    end function ${prefix}$nrm2
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_nrm2_r${wp}$
    module procedure :: blas_nrm2_c${wp}$
  #:endfor
  end interface blas_nrm2

  !> Finds the index of the first element having maximum absolute value.
  interface blas_iamax
  #:for prefix, wp in BLAS_REAL
    pure function i${prefix}$amax(n, x, incx) result(iamax)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      integer(ik) :: iamax
    end function i${prefix}$amax
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure function i${prefix}$amax(n, x, incx) result(iamax)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      integer(ik) :: iamax
    end function i${prefix}$amax
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_iamax_r${wp}$
    module procedure :: blas_iamax_c${wp}$
  #:endfor
  end interface blas_iamax

contains

#:for wp in BLAS_KIND
  pure subroutine blas_axpy_r${wp}$(xvec, yvec, alpha)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    real(wp), intent(in), optional :: alpha

    integer(ik) :: n
    real(wp) :: a

    n = size(xvec)
    a = 1.0_wp
    if (present(alpha)) a = alpha
    call blas_axpy(n, a, xvec, 1, yvec, 1)
  end subroutine blas_axpy_r${wp}$

  pure subroutine blas_axpy_c${wp}$(xvec, yvec, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    complex(wp), intent(in), optional :: alpha

    integer(ik) :: n
    complex(wp) :: a

    n = size(xvec)
    a = 1.0_wp
    if (present(alpha)) a = alpha
    call blas_axpy(n, a, xvec, 1, yvec, 1)
  end subroutine blas_axpy_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_copy_r${wp}$(xvec, yvec)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_copy(n, xvec, 1, yvec, 1)
  end subroutine blas_copy_r${wp}$

  pure subroutine blas_copy_c${wp}$(xvec, yvec)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_copy(n, xvec, 1, yvec, 1)
  end subroutine blas_copy_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure function blas_dot_r${wp}$(xvec, yvec) result(dot)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(in) :: yvec(:)
    real(wp) :: dot

    integer(ik) :: n

    n = size(xvec)
    dot = blas_dot(n, xvec, 1, yvec, 1)
  end function blas_dot_r${wp}$

  pure function blas_dotc_c${wp}$(xvec, yvec) result(dotc)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(in) :: yvec(:)
    complex(wp) :: dotc

    integer(ik) :: n

    n = size(xvec)
    dotc = blas_dotc(n, xvec, 1, yvec, 1)
  end function blas_dotc_c${wp}$

  pure function blas_dotu_c${wp}$(xvec, yvec) result(dotu)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(in) :: yvec(:)
    complex(wp) :: dotu

    integer(ik) :: n

    n = size(xvec)
    dotu = blas_dotu(n, xvec, 1, yvec, 1)
  end function blas_dotu_c${wp}$
#:endfor

  pure function blas_dsdot_rspdp(xvec, yvec) result(dot)
    real(sp), contiguous, intent(in) :: xvec(:)
    real(sp), contiguous, intent(in) :: yvec(:)
    real(dp) :: dot

    integer(ik) :: n

    n = size(xvec)
    dot = blas_dsdot(n, xvec, 1, yvec, 1)
  end function blas_dsdot_rspdp

  pure function blas_sdsdot_rsp(beta, xvec, yvec) result(dot)
    real(sp), intent(in) :: beta
    real(sp), contiguous, intent(in) :: xvec(:)
    real(sp), contiguous, intent(in) :: yvec(:)
    real(sp) :: dot

    integer(ik) :: n

    n = size(xvec)
    dot = blas_sdsdot(n, beta, xvec, 1, yvec, 1)
  end function blas_sdsdot_rsp

#:for wp in BLAS_KIND
  pure subroutine blas_rotm_r${wp}$(xvec, yvec, param)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(inout) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    real(wp), contiguous, intent(in) :: param(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_rotm(n, xvec, 1, yvec, 1, param)
  end subroutine blas_rotm_r${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_scal_r${wp}$(alpha, xvec)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: alpha
    real(wp), contiguous, intent(inout) :: xvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_scal(n, alpha, xvec, 1)
  end subroutine blas_scal_r${wp}$

  pure subroutine blas_scal_rc${wp}$(alpha, xvec)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: alpha
    complex(wp), contiguous, intent(inout) :: xvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_scal(n, alpha, xvec, 1)
  end subroutine blas_scal_rc${wp}$

  pure subroutine blas_scal_c${wp}$(alpha, xvec)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: alpha
    complex(wp), contiguous, intent(inout) :: xvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_scal(n, alpha, xvec, 1)
  end subroutine blas_scal_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_rot_r${wp}$(xvec, yvec, c, s)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(inout) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    real(wp), intent(in) :: c
    real(wp), intent(in) :: s

    integer(ik) :: n

    n = size(xvec)
    call blas_rot(n, xvec, 1, yvec, 1, c, s)
  end subroutine blas_rot_r${wp}$

  pure subroutine blas_rot_c${wp}$(xvec, yvec, c, s)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(inout) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    real(wp), intent(in) :: c
    real(wp), intent(in) :: s

    integer(ik) :: n

    n = size(xvec)
    call blas_rot(n, xvec, 1, yvec, 1, c, s)
  end subroutine blas_rot_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_swap_r${wp}$(xvec, yvec)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(inout) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_swap(n, xvec, 1, yvec, 1)
  end subroutine blas_swap_r${wp}$

  pure subroutine blas_swap_c${wp}$(xvec, yvec)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(inout) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)

    integer(ik) :: n

    n = size(xvec)
    call blas_swap(n, xvec, 1, yvec, 1)
  end subroutine blas_swap_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure function blas_asum_r${wp}$(xvec) result(asum)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp) :: asum

    integer(ik) :: n

    n = size(xvec)
    asum = blas_asum(n, xvec, 1)
  end function blas_asum_r${wp}$

  pure function blas_asum_c${wp}$(xvec) result(asum)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    real(wp) :: asum

    integer(ik) :: n

    n = size(xvec)
    asum = blas_asum(n, xvec, 1)
  end function blas_asum_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure function blas_nrm2_r${wp}$(xvec) result(nrm2)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp) :: nrm2

    integer(ik) :: n

    n = size(xvec)
    nrm2 = blas_nrm2(n, xvec, 1)
  end function blas_nrm2_r${wp}$

  pure function blas_nrm2_c${wp}$(xvec) result(nrm2)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    real(wp) :: nrm2

    integer(ik) :: n

    n = size(xvec)
    nrm2 = blas_nrm2(n, xvec, 1)
  end function blas_nrm2_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure function blas_iamax_r${wp}$(xvec) result(iamax)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: xvec(:)
    integer(ik) :: iamax

    integer(ik) :: n

    n = size(xvec)
    iamax = blas_iamax(n, xvec, 1)
  end function blas_iamax_r${wp}$

  pure function blas_iamax_c${wp}$(xvec) result(iamax)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: xvec(:)
    integer(ik) :: iamax

    integer(ik) :: n

    n = size(xvec)
    iamax = blas_iamax(n, xvec, 1)
  end function blas_iamax_c${wp}$
#:endfor

end module stdlib_linalg_blas1
