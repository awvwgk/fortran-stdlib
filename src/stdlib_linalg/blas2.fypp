! SPDX-Identifier: MIT

#:set BLAS_KIND = ["sp", "dp"]
#:set BLAS_REAL = [("s", "sp"), ("d", "dp")]
#:set BLAS_COMPLEX = [("c", "sp"), ("z", "dp")]

!> Interfaces to level 2 BLAS routines.
module stdlib_linalg_blas2
  use stdlib_kinds, only : ik => int32, sp, dp
  implicit none
  private

  public :: blas_gbmv, blas_gemv, blas_ger, blas_gerc, blas_geru, blas_sbmv, blas_spmv, &
    & blas_hbmv, blas_hemv, blas_spr2, blas_spr, blas_syr2, blas_syr, blas_her2, blas_her, &
    & blas_symv, blas_hpmv, blas_hpr2, blas_hpr, blas_tbmv, blas_tbsv, blas_tpmv, blas_tpsv, &
    & blas_trmv, blas_trsv

  !> Performs one of the matrix-vector operations
  !>
  !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are vectors and A is an
  !> m by n band matrix, with kl sub-diagonals and ku super-diagonals.
  interface blas_gbmv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$gbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: trans
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: kl
      integer(ik), intent(in) :: ku
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: beta
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$gbmv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$gbmv(trans, m, n, kl, ku, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: trans
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: kl
      integer(ik), intent(in) :: ku
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: beta
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$gbmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_gbmv_r${wp}$
    module procedure :: blas_gbmv_c${wp}$
  #:endfor
  end interface blas_gbmv

  !> Performs one of the matrix-vector operations
  !>
  !>    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are vectors and A is an
  !> m by n matrix.
  interface blas_gemv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$gemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: trans
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: beta
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$gemv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$gemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: trans
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: beta
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$gemv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_gemv_r${wp}$
    module procedure :: blas_gemv_c${wp}$
  #:endfor
  end interface blas_gemv


  !> Performs the rank 1 operation
  !>
  !>    A := alpha*x*y**T + A,
  !>
  !> where alpha is a scalar, x is an m element vector, y is an n element
  !> vector and A is an m by n matrix.
  interface blas_ger
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$ger(m, n, alpha, x, incx, y, incy, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$ger
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_ger_r${wp}$
  #:endfor
  end interface blas_ger

  !> Performs the rank 1 operation
  !>
  !>    A := alpha*x*y**H + A,
  !>
  !> where alpha is a scalar, x is an m element vector, y is an n element
  !> vector and A is an m by n matrix.
  interface blas_gerc
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$gerc(m, n, alpha, x, incx, y, incy, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      complex(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$gerc
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_gerc_c${wp}$
  #:endfor
  end interface blas_gerc

  !> Performs the rank 1 operation
  !>
  !>    A := alpha*x*y**T + A,
  !>
  !> where alpha is a scalar, x is an m element vector, y is an n element
  !> vector and A is an m by n matrix.
  interface blas_geru
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$geru(m, n, alpha, x, incx, y, incy, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      integer(ik), intent(in) :: m
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      complex(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$geru
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_geru_c${wp}$
  #:endfor
  end interface blas_geru

  !> Performs the matrix-vector  operation
  !>
  !>    y := alpha*A*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are n element vectors and
  !> A is an n by n symmetric band matrix, with k super-diagonals.
  interface blas_sbmv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$sbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: k
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: beta
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$sbmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_sbmv_r${wp}$
  #:endfor
  end interface blas_sbmv

  !> Performs the matrix-vector operation
  !>
  !>    y := alpha*A*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are n element vectors and
  !> A is an n by n symmetric matrix, supplied in packed form.
  interface blas_spmv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$spmv(uplo, n, alpha, ap, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: ap(*)
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: beta
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$spmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_spmv_r${wp}$
  #:endfor
  end interface blas_spmv

  !> Performs the matrix-vector  operation
  !>
  !>    y := alpha*A*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are n element vectors and
  !> A is an n by n hermitian band matrix, with k super-diagonals.
  interface blas_hbmv
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$hbmv(uplo, n, k, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: k
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: beta
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$hbmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_hbmv_c${wp}$
  #:endfor
  end interface blas_hbmv

  !> Performs the matrix-vector  operation
  !>
  !>    y := alpha*A*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are n element vectors and
  !> A is an n by n hermitian matrix.
  interface blas_hemv
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$hemv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: beta
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$hemv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_hemv_c${wp}$
  #:endfor
  end interface blas_hemv

  !> Performs the symmetric rank 2 operation
  !>
  !>    A := alpha*x*y**T + alpha*y*x**T + A,
  !>
  !> where alpha is a scalar, x and y are n element vectors and A is an
  !> n by n symmetric matrix, supplied in packed form.
  interface blas_spr2
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$spr2(uplo, n, alpha, x, incx, y, incy, ap)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp), intent(inout) :: ap(*)
    end subroutine ${prefix}$spr2
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_spr2_r${wp}$
  #:endfor
  end interface blas_spr2

  !> Performs the symmetric rank 1 operation
  !>
  !>    A := alpha*x*x**T + A,
  !>
  !> where alpha is a real scalar, x is an n element vector and A is an
  !> n by n symmetric matrix, supplied in packed form.
  interface blas_spr
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$spr(uplo, n, alpha, x, incx, ap)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: ap(*)
    end subroutine ${prefix}$spr
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_spr_r${wp}$
  #:endfor
  end interface blas_spr

  !> Performs the symmetric rank 2 operation
  !>
  !>    A := alpha*x*y**T + alpha*y*x**T + A,
  !>
  !> where alpha is a scalar, x and y are n element vectors and A is an n
  !> by n symmetric matrix.
  interface blas_syr2
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$syr2(uplo, n, alpha, x, incx, y, incy, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      real(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$syr2
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_syr2_r${wp}$
  #:endfor
  end interface blas_syr2

  !> Performs the symmetric rank 1 operation
  !>
  !>    A := alpha*x*x**T + A,
  !>
  !> where alpha is a real scalar, x is an n element vector and A is an
  !> n by n symmetric matrix.
  interface blas_syr
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$syr(uplo, n, alpha, x, incx, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$syr
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_syr_r${wp}$
  #:endfor
  end interface blas_syr

  !> Performs the hermitian rank 2 operation
  !>
  !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
  !>
  !> where alpha is a scalar, x and y are n element vectors and A is an n
  !> by n hermitian matrix.
  interface blas_her2
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$her2(uplo, n, alpha, x, incx, y, incy, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      complex(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$her2
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_her2_c${wp}$
  #:endfor
  end interface blas_her2

  !> Performs the hermitian rank 1 operation
  !>
  !>    A := alpha*x*x**H + A,
  !>
  !> where alpha is a real scalar, x is an n element vector and A is an
  !> n by n hermitian matrix.
  interface blas_her
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$her(uplo, n, alpha, x, incx, a, lda)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(inout) :: a(lda, *)
    end subroutine ${prefix}$her
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_her_c${wp}$
  #:endfor
  end interface blas_her

  !> Performs the matrix-vector  operation
  !>
  !>    y := alpha*A*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are n element vectors and
  !> A is an n by n symmetric matrix.
  interface blas_symv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$symv(uplo, n, alpha, a, lda, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      real(wp), intent(in) :: beta
      real(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$symv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_symv_r${wp}$
  #:endfor
  end interface blas_symv

  !> Performs the matrix-vector operation
  !>
  !>    y := alpha*A*x + beta*y,
  !>
  !> where alpha and beta are scalars, x and y are n element vectors and
  !> A is an n by n hermitian matrix, supplied in packed form.
  interface blas_hpmv
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$hpmv(uplo, n, alpha, ap, x, incx, beta, y, incy)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: ap(*)
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: beta
      complex(wp), intent(inout) :: y(*)
      integer(ik), intent(in) :: incy
    end subroutine ${prefix}$hpmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_hpmv_c${wp}$
  #:endfor
  end interface blas_hpmv

  !> Performs the hermitian rank 2 operation
  !>
  !>    A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
  !>
  !> where alpha is a scalar, x and y are n element vectors and A is an
  !> n by n hermitian matrix, supplied in packed form.
  interface blas_hpr2
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$hpr2(uplo, n, alpha, x, incx, y, incy, ap)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: alpha
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(in) :: y(*)
      integer(ik), intent(in) :: incy
      complex(wp), intent(inout) :: ap(*)
    end subroutine ${prefix}$hpr2
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_hpr2_c${wp}$
  #:endfor
  end interface blas_hpr2

  !> Performs the hermitian rank 1 operation
  !>
  !>    A := alpha*x*x**H + A,
  !>
  !> where alpha is a real scalar, x is an n element vector and A is an
  !> n by n hermitian matrix, supplied in packed form.
  interface blas_hpr
  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$hpr(uplo, n, alpha, x, incx, ap)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: alpha
      complex(wp), intent(in) :: x(*)
      integer(ik), intent(in) :: incx
      complex(wp), intent(inout) :: ap(*)
    end subroutine ${prefix}$hpr
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_hpr_c${wp}$
  #:endfor
  end interface blas_hpr

  !> Performs one of the matrix-vector operations
  !>
  !>    x := A*x,   or   x := A**T*x,
  !>
  !> where x is an n element vector and  A is an n by n unit, or non-unit,
  !> upper or lower triangular band matrix, with ( k + 1 ) diagonals.
  interface blas_tbmv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$tbmv(uplo, trans, diag, n, k, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: k
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tbmv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$tbmv(uplo, trans, diag, n, k, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: k
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tbmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_tbmv_r${wp}$
    module procedure :: blas_tbmv_c${wp}$
  #:endfor
  end interface blas_tbmv

  !> Solves one of the systems of equations
  !>
  !>    A*x = b,   or   A**T*x = b,
  !>
  !> where b and x are n element vectors and A is an n by n unit, or
  !> non-unit, upper or lower triangular band matrix, with ( k + 1 )
  !> diagonals.
  !>
  !> No test for singularity or near-singularity is included in this
  !> routine. Such tests must be performed before calling this routine.
  interface blas_tbsv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$tbsv(uplo, trans, diag, n, k, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: k
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tbsv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$tbsv(uplo, trans, diag, n, k, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      integer(ik), intent(in) :: k
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tbsv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_tbsv_r${wp}$
    module procedure :: blas_tbsv_c${wp}$
  #:endfor
  end interface blas_tbsv

  !> Performs one of the matrix-vector operations
  !>
  !>    x := A*x,   or   x := A**T*x,
  !>
  !> where x is an n element vector and  A is an n by n unit, or non-unit,
  !> upper or lower triangular matrix, supplied in packed form.
  interface blas_tpmv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$tpmv(uplo, trans, diag, n, ap, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: ap(*)
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tpmv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$tpmv(uplo, trans, diag, n, ap, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: ap(*)
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tpmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_tpmv_r${wp}$
    module procedure :: blas_tpmv_c${wp}$
  #:endfor
  end interface blas_tpmv

  !> Solves one of the systems of equations
  !>
  !>    A*x = b,   or   A**T*x = b,
  !>
  !> where b and x are n element vectors and A is an n by n unit, or
  !> non-unit, upper or lower triangular matrix, supplied in packed form.
  !>
  !> No test for singularity or near-singularity is included in this
  !> routine. Such tests must be performed before calling this routine.
  interface blas_tpsv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$tpsv(uplo, trans, diag, n, ap, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: ap(*)
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tpsv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$tpsv(uplo, trans, diag, n, ap, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: ap(*)
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$tpsv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_tpsv_r${wp}$
    module procedure :: blas_tpsv_c${wp}$
  #:endfor
  end interface blas_tpsv

  !> Performs one of the matrix-vector operations
  !
  !>    x := A*x,   or   x := A**T*x,
  !>
  !> where x is an n element vector and  A is an n by n unit, or non-unit,
  !> upper or lower triangular matrix.
  interface blas_trmv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$trmv(uplo, trans, diag, n, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$trmv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$trmv(uplo, trans, diag, n, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$trmv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_trmv_r${wp}$
    module procedure :: blas_trmv_c${wp}$
  #:endfor
  end interface blas_trmv

  !> Solves one of the systems of equations
  !>
  !>    A*x = b,   or   A**T*x = b,
  !>
  !> where b and x are n element vectors and A is an n by n unit, or
  !> non-unit, upper or lower triangular matrix.
  !>
  !> No test for singularity or near-singularity is included in this
  !> routine. Such tests must be performed before calling this routine.
  interface blas_trsv
  #:for prefix, wp in BLAS_REAL
    pure subroutine ${prefix}$trsv(uplo, trans, diag, n, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      real(wp), intent(in) :: a(lda, *)
      real(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$trsv
  #:endfor

  #:for prefix, wp in BLAS_COMPLEX
    pure subroutine ${prefix}$trsv(uplo, trans, diag, n, a, lda, x, incx)
      import :: ik, ${wp}$
      integer, parameter :: wp = ${wp}$
      integer(ik), intent(in) :: lda
      character, intent(in) :: uplo
      character, intent(in) :: trans
      character, intent(in) :: diag
      integer(ik), intent(in) :: n
      complex(wp), intent(in) :: a(lda, *)
      complex(wp), intent(inout) :: x(*)
      integer(ik), intent(in) :: incx
    end subroutine ${prefix}$trsv
  #:endfor

  #:for wp in BLAS_KIND
    module procedure :: blas_trsv_r${wp}$
    module procedure :: blas_trsv_c${wp}$
  #:endfor
  end interface blas_trsv


contains

#:for wp in BLAS_KIND
  pure subroutine blas_gbmv_r${wp}$(amat, xvec, yvec, kl, m, alpha, beta, trans)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: amat(:, :)
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    integer, intent(in), optional :: kl
    integer, intent(in), optional :: m
    real(wp), intent(in), optional :: alpha
    real(wp), intent(in), optional :: beta
    character, intent(in), optional :: trans

    integer(ik) :: n, ku, lda
    integer(ik) :: kl_, m_
    real(wp) :: a, b
    character :: tra

    a = 1.0_wp
    if (present(alpha)) a = alpha
    b = 0.0_wp
    if (present(beta)) b = beta
    tra = 'n'
    if (present(trans)) tra = trans
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    kl_ = (lda-1)/2
    if (present(kl)) kl_ = kl
    m_ = n
    if (present(m)) m_ = m
    ku = lda-kl_-1
    call blas_gbmv(tra, m_, n, kl_, ku, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_gbmv_r${wp}$

  pure subroutine blas_gbmv_c${wp}$(amat, xvec, yvec, kl, m, alpha, beta, trans)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: amat(:, :)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    integer, intent(in), optional :: kl
    integer, intent(in), optional :: m
    complex(wp), intent(in), optional :: alpha
    complex(wp), intent(in), optional :: beta
    character, intent(in), optional :: trans

    integer(ik) :: n, ku, lda
    integer(ik) :: kl_, m_
    complex(wp) :: a, b
    character :: tra

    a = 1.0_wp
    if (present(alpha)) a = alpha
    b = 0.0_wp
    if (present(beta)) b = beta
    tra = 'n'
    if (present(trans)) tra = trans
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    kl_ = (lda-1)/2
    if (present(kl)) kl_ = kl
    m_ = n
    if (present(m)) m_ = m
    ku = lda-kl_-1
    call blas_gbmv(tra, m_, n, kl_, ku, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_gbmv_c${wp}$
#:endfor


#:for wp in BLAS_KIND
  pure subroutine blas_gemv_r${wp}$(amat, xvec, yvec, alpha, beta, trans)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: amat(:, :)
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    real(wp), intent(in), optional :: alpha
    real(wp), intent(in), optional :: beta
    character, intent(in), optional :: trans

    real(wp) :: a, b
    character :: tra
    integer(ik) :: m, n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    b = 0.0_wp
    if (present(beta)) b = beta
    tra = 'n'
    if (present(trans)) tra = trans
    lda = max(1, size(amat, 1))
    m = size(amat, 1)
    n = size(amat, 2)
    call blas_gemv(tra, m, n, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_gemv_r${wp}$

  pure subroutine blas_gemv_c${wp}$(amat, xvec, yvec, alpha, beta, trans)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: amat(:, :)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    complex(wp), intent(in), optional :: alpha
    complex(wp), intent(in), optional :: beta
    character, intent(in), optional :: trans

    complex(wp) :: a, b
    character :: tra
    integer(ik) :: m, n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    b = 0.0_wp
    if (present(beta)) b = beta
    tra = 'n'
    if (present(trans)) tra = trans
    lda = max(1, size(amat, 1))
    m = size(amat, 1)
    n = size(amat, 2)
    call blas_gemv(tra, m, n, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_gemv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_ger_r${wp}$(amat, xvec, yvec, alpha)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(inout) :: amat(:, :)
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(in) :: yvec(:)
    real(wp), intent(in), optional :: alpha

    real(wp) :: a
    integer(ik) :: m, n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    lda = max(1, size(amat, 1))
    m = size(amat, 1)
    n = size(amat, 2)
    call blas_ger(m, n, a, xvec, 1, yvec, 1, amat, lda)
  end subroutine blas_ger_r${wp}$

  pure subroutine blas_gerc_c${wp}$(amat, xvec, yvec, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(inout) :: amat(:, :)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(in) :: yvec(:)
    complex(wp), intent(in), optional :: alpha

    complex(wp) :: a
    integer(ik) :: m, n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    lda = max(1, size(amat, 1))
    m = size(amat, 1)
    n = size(amat, 2)
    call blas_gerc(m, n, a, xvec, 1, yvec, 1, amat, lda)
  end subroutine blas_gerc_c${wp}$

  pure subroutine blas_geru_c${wp}$(amat, xvec, yvec, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(inout) :: amat(:, :)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(in) :: yvec(:)
    complex(wp), intent(in), optional :: alpha

    complex(wp) :: a
    integer(ik) :: m, n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    lda = max(1, size(amat, 1))
    m = size(amat, 1)
    n = size(amat, 2)
    call blas_geru(m, n, a, xvec, 1, yvec, 1, amat, lda)
  end subroutine blas_geru_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_sbmv_r${wp}$(amat, xvec, yvec, uplo, alpha, beta)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: amat(:, :)
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha
    real(wp), intent(in), optional :: beta

    character :: ula
    real(wp) :: a, b
    integer(ik) :: n, k, lda

    a = 1
    if (present(alpha)) a = alpha
    b = 0
    if (present(beta)) b = beta
    ula = 'u'
    if (present(uplo)) ula = uplo
    k = size(amat, 1)-1
    lda = max(1, size(amat, 1))
    n = size(xvec)
    call blas_sbmv(ula, n, k, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_sbmv_r${wp}$

  pure subroutine blas_hbmv_c${wp}$(amat, xvec, yvec, uplo, alpha, beta)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: amat(:, :)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    character, intent(in), optional :: uplo
    complex(wp), intent(in), optional :: alpha
    complex(wp), intent(in), optional :: beta

    character :: ula
    complex(wp) :: a, b
    integer(ik) :: n, k, lda

    a = 1
    if (present(alpha)) a = alpha
    b = 0
    if (present(beta)) b = beta
    ula = 'u'
    if (present(uplo)) ula = uplo
    k = size(amat, 1)-1
    lda = max(1, size(amat, 1))
    n = size(xvec)
    call blas_hbmv(ula, n, k, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_hbmv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_spmv_r${wp}$(apmat, xvec, yvec, uplo, alpha, beta)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: apmat(:)
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha
    real(wp), intent(in), optional :: beta

    character :: ula
    real(wp) :: a, b
    integer(ik) :: n

    a = 1
    if (present(alpha)) a = alpha
    b = 0
    if (present(beta)) b = beta
    ula = 'u'
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_spmv(ula, n, a, apmat, xvec, 1, b, yvec, 1)
  end subroutine blas_spmv_r${wp}$

  pure subroutine blas_hpmv_c${wp}$(apmat, xvec, yvec, uplo, alpha, beta)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: apmat(:)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    character, intent(in), optional :: uplo
    complex(wp), intent(in), optional :: alpha
    complex(wp), intent(in), optional :: beta

    character :: ula
    complex(wp) :: a, b
    integer(ik) :: n

    a = 1
    if (present(alpha)) a = alpha
    b = 0
    if (present(beta)) b = beta
    ula = 'u'
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_hpmv(ula, n, a, apmat, xvec, 1, b, yvec, 1)
  end subroutine blas_hpmv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_symv_r${wp}$(amat, xvec, yvec, uplo, alpha, beta)
    integer, parameter :: wp = ${wp}$
    real(wp), contiguous, intent(in) :: amat(:, :)
    real(wp), contiguous, intent(in) :: xvec(:)
    real(wp), contiguous, intent(inout) :: yvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha
    real(wp), intent(in), optional :: beta

    character :: ula
    real(wp) :: a, b
    integer(ik) :: n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    b = 0.0_wp
    if (present(beta)) b = beta
    ula = 'u'
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_symv(ula, n, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_symv_r${wp}$

  pure subroutine blas_hemv_c${wp}$(amat, xvec, yvec, uplo, alpha, beta)
    integer, parameter :: wp = ${wp}$
    complex(wp), contiguous, intent(in) :: amat(:, :)
    complex(wp), contiguous, intent(in) :: xvec(:)
    complex(wp), contiguous, intent(inout) :: yvec(:)
    character, intent(in), optional :: uplo
    complex(wp), intent(in), optional :: alpha
    complex(wp), intent(in), optional :: beta

    character :: ula
    complex(wp) :: a, b
    integer(ik) :: n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    b = 0.0_wp
    if (present(beta)) b = beta
    ula = 'u'
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_hemv(ula, n, a, amat, lda, xvec, 1, b, yvec, 1)
  end subroutine blas_hemv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_spr2_r${wp}$(apmat, xvec, yvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(inout) :: apmat(:)
    real(wp), intent(in) :: xvec(:)
    real(wp), intent(in) :: yvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha

    character :: ula
    real(wp) :: a
    integer(ik) :: n

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_spr2(ula, n, a, xvec, 1, yvec, 1, apmat)
  end subroutine blas_spr2_r${wp}$

  pure subroutine blas_hpr2_c${wp}$(apmat, xvec, yvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(inout) :: apmat(:)
    complex(wp), intent(in) :: xvec(:)
    complex(wp), intent(in) :: yvec(:)
    character, intent(in), optional :: uplo
    complex(wp), intent(in), optional :: alpha

    character :: ula
    complex(wp) :: a
    integer(ik) :: n

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_hpr2(ula, n, a, xvec, 1, yvec, 1, apmat)
  end subroutine blas_hpr2_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_spr_r${wp}$(amat, xvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(inout) :: amat(:)
    real(wp), intent(in) :: xvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha

    character :: ula
    real(wp) :: a
    integer(ik) :: n

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_spr(ula, n, a, xvec, 1, amat)
  end subroutine blas_spr_r${wp}$

  pure subroutine blas_hpr_c${wp}$(amat, xvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(inout) :: amat(:)
    complex(wp), intent(in) :: xvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha

    character :: ula
    real(wp) :: a
    integer(ik) :: n

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_hpr(ula, n, a, xvec, 1, amat)
  end subroutine blas_hpr_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_syr_r${wp}$(amat, xvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(inout) :: amat(:, :)
    real(wp), intent(in) :: xvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha

    character :: ula
    real(wp) :: a
    integer(ik) :: n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_syr(ula, n, a, xvec, 1, amat, lda)
  end subroutine blas_syr_r${wp}$

  pure subroutine blas_her_c${wp}$(amat, xvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(inout) :: amat(:, :)
    complex(wp), intent(in) :: xvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha

    character :: ula
    real(wp) :: a
    integer(ik) :: n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_her(ula, n, a, xvec, 1, amat, lda)
  end subroutine blas_her_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_syr2_r${wp}$(amat, xvec, yvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(inout) :: amat(:, :)
    real(wp), intent(in) :: xvec(:)
    real(wp), intent(in) :: yvec(:)
    character, intent(in), optional :: uplo
    real(wp), intent(in), optional :: alpha

    character :: ula
    real(wp) :: a
    integer(ik) :: n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_syr2(ula, n, a, xvec, 1, yvec, 1, amat, lda)
  end subroutine blas_syr2_r${wp}$

  pure subroutine blas_her2_c${wp}$(amat, xvec, yvec, uplo, alpha)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(inout) :: amat(:, :)
    complex(wp), intent(in) :: xvec(:)
    complex(wp), intent(in) :: yvec(:)
    character, intent(in), optional :: uplo
    complex(wp), intent(in), optional :: alpha

    character :: ula
    complex(wp) :: a
    integer(ik) :: n, lda

    a = 1.0_wp
    if (present(alpha)) a = alpha
    ula = 'u'
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_her2(ula, n, a, xvec, 1, yvec, 1, amat, lda)
  end subroutine blas_her2_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_tbmv_r${wp}$(amat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: amat(:, :)
    real(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, k, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    k = size(amat, 1)-1
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_tbmv(ula, tra, dia, n, k, amat, lda, xvec, 1)
  end subroutine blas_tbmv_r${wp}$

  pure subroutine blas_tbmv_c${wp}$(amat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: amat(:, :)
    complex(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, k, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    k = size(amat, 1)-1
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_tbmv(ula, tra, dia, n, k, amat, lda, xvec, 1)
  end subroutine blas_tbmv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_tbsv_r${wp}$(amat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: amat(:, :)
    real(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, k, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    k = size(amat, 1)-1
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_tbsv(ula, tra, dia, n, k, amat, lda, xvec, 1)
  end subroutine blas_tbsv_r${wp}$

  pure subroutine blas_tbsv_c${wp}$(amat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: amat(:, :)
    complex(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, k, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    k = size(amat, 1)-1
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_tbsv(ula, tra, dia, n, k, amat, lda, xvec, 1)
  end subroutine blas_tbsv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_tpmv_r${wp}$(apmat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: apmat(:)
    real(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_tpmv(ula, tra, dia, n, apmat, xvec, 1)
  end subroutine blas_tpmv_r${wp}$

  pure subroutine blas_tpmv_c${wp}$(apmat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: apmat(:)
    complex(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_tpmv(ula, tra, dia, n, apmat, xvec,  1)
  end subroutine blas_tpmv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_tpsv_r${wp}$(apmat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: apmat(:)
    real(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_tpsv(ula, tra, dia, n, apmat, xvec, 1)
  end subroutine blas_tpsv_r${wp}$

  pure subroutine blas_tpsv_c${wp}$(apmat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: apmat(:)
    complex(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    n = size(xvec)
    call blas_tpsv(ula, tra, dia, n, apmat, xvec, 1)
  end subroutine blas_tpsv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_trmv_r${wp}$(amat,  xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: amat(:, :)
    real(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_trmv(ula, tra, dia, n, amat, lda, xvec, 1)
  end subroutine blas_trmv_r${wp}$

  pure subroutine blas_trmv_c${wp}$(amat,  xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: amat(:, :)
    complex(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_trmv(ula, tra, dia, n, amat, lda, xvec, 1)
  end subroutine blas_trmv_c${wp}$
#:endfor

#:for wp in BLAS_KIND
  pure subroutine blas_trsv_r${wp}$(amat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    real(wp), intent(in) :: amat(:, :)
    real(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_trsv(ula, tra, dia, n, amat, lda, xvec, 1)
  end subroutine blas_trsv_r${wp}$

  pure subroutine blas_trsv_c${wp}$(amat, xvec, uplo, trans, diag)
    integer, parameter :: wp = ${wp}$
    complex(wp), intent(in) :: amat(:, :)
    complex(wp), intent(inout) :: xvec(:)
    character, intent(in), optional :: uplo
    character, intent(in), optional :: trans
    character, intent(in), optional :: diag

    character :: ula, tra, dia
    integer(ik) :: n, lda

    dia = 'n'
    tra = 'n'
    ula = 'u'
    if (present(diag)) dia = diag
    if (present(trans)) tra = trans
    if (present(uplo)) ula = uplo
    lda = max(1, size(amat, 1))
    n = size(amat, 2)
    call blas_trsv(ula, tra, dia, n, amat, lda, xvec, 1)
  end subroutine blas_trsv_c${wp}$
#:endfor

end module stdlib_linalg_blas2
